/*
 * BSD License
 *
 * Copyright (c) Lydia Zoghbi 2019
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/**
 *  @file       walker.cpp
 *  @author     Lydia Zoghbi
 *  @copyright  Copyright BSD License
 *  @date       11/18/2019
 *  @version    1.0
 *
 *  @brief      Walker class implementation file
 *
 */

#include <iostream>
#include "walker.hpp"
#include "geometry_msgs/Twist.h"
#include "sensor_msgs/LaserScan.h"

// Define the default message rate
int Walker::msg_rate = 1;

Walker::Walker() {
	// Advertise the velocity message
	pub = nh.advertise<geometry_msgs::Twist>("/cmd_vel_mux/input/navi", 500);

	// Subscribe to the sensor laser scan readings
	sub = nh.subscribe("/scan", 500, &Walker::GetSensorReadings, this);

	// Initialize all velocities to zero at the beginning
	velocity.linear.x = 0;
	velocity.linear.y = 0;
	velocity.linear.z = 0;
	velocity.angular.x = 0;
	velocity.angular.y = 0;
	velocity.angular.z = 0;
}

void Walker::SetRate(const int& rate) {
	// Set the message rate to rate
	msg_rate = rate;
}

geometry_msgs::Twist Walker::MoveStraight(const double& forwardVelocity) {
	// Assign linear velocities to move the robot forward
	velocity.linear.x = forwardVelocity;
	velocity.angular.z = 0;
	return velocity;
}

geometry_msgs::Twist Walker::Rotate(const double& angle) {
	// Assign angular and linear velocities to rotate the robot and move it
	velocity.linear.x = 0.1;
	velocity.angular.z = angle;
	return velocity;
}

void Walker::GetSensorReadings(const sensor_msgs::LaserScanConstPtr& scans) {
	// Find the distance between the first and last sensor readings
	auto minimumDistance = std::min_element(scans -> ranges.begin(), scans -> ranges.end());

	// Specify threshold after which the robot has to turn
	double threshold = 4.0;

	// If the threshold is crossed
	if(*minimumDistance <threshold) {
		auto iterations = std::find(scans->ranges.begin(), scans->ranges.end(), *minimumDistance);
		auto currentPosition = iterations - scans->ranges.begin();
		double absDistance = scans->ranges.end() - scans->ranges.begin();

		// Check if there are obstacles on right
		if (currentPosition <= (absDistance/2.0)) {
			angle = 1;
		// Check if there are obstacles on left
		} else if (currentPosition >  (absDistance/2.0)) {
			angle = -1;
		}
	} else {
		angle = 0;
	}
}

void Walker::Explore() {
	// Specify the ROS loop rate
	ros::Rate loop_rate(msg_rate);

	// Start publishing the velocities to move the robot forward
	pub.publish(MoveStraight(0.15));

	while (ros::ok()) {
		ros::Rate loop_rate(msg_rate);
		// If no obstacles are observed keeo moving straight
		if (angle == 0) {
			pub.publish(MoveStraight(0.15));
		}

		// If no obstacles on the right turn clockwise
		while (angle == 1) {
			pub.publish(Rotate(-50));
			ros::spinOnce();
			loop_rate.sleep();
			// Output info on screen fot guidance
			ROS_INFO_STREAM("Rotating clockwise");
		}

		// If not obstacles on left turn counterclockwise
		while (angle == -1) {
			pub.publish(Rotate(50));
			ros::spinOnce();
			loop_rate.sleep();
			// Output info on screen fot guidance
			ROS_INFO_STREAM("Rotating counter-clockwise");
		}

		ros::spinOnce();
		loop_rate.sleep();
	}
}

